<!DOCTYPE html>
<html>
  <head>
    <title>What are we doing for things we want? –  – Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="What are we doing for things we want?

Mac Mini ဝယ်ရမလား 
iPad Pro ဝယ်ရမလား?

အလုပ်အတွက်ကတော့ Mac Mini က ပိုကောင်းတယ်။ ပိုပြီးအသုံးဝင်မယ်။
iPad Pro ကတော့ ကိုယ့်ရဲ့ အာသီသအတွက်။
အလုပ်အတွက်လည်း အနည်းနဲ့အများ အထောက်အကူပြုမယ်ဆိုပေမယ့် Mac Mini နဲ့ တော့ မယှဉ်သာဘူး။

နှစ်ခုလုံး ဝယ်နိုင်အောင် လုပ်တာပေါ့။

MAP-BY-KMT က Ads ကိစ္စ ပြီးရင် အကုန်ပြီးပြီ ပြောရမယ်။

iPad Pro အတွက်က Movie Streaming ကို အာရုံစိုက်ရမှာပေါ့ ။ ဒီ Janaray တစ်လ အာရုံစိုက်ပြီးလုပ်ရင် ရမယ်ထင်တယ်။

iPad Pro က instance pleasure ကို ရမယ်။
second screen ရမယ်။
pan နဲ့ ဘာနဲ့ စာသင်တဲ့အခါ အဆင်ပြေကောင်း ပိုပြေလာမယ်။

mac mini ကတော့ ပြန်ရောက်တဲ့အခါ ပိုပြီး Professional ဆန်လာမယ်။

နှစ်ခုလုံးကတော့ မြန်မာနိုင်ငံမှာဆို ဝယ်ဖို့ အဆင်မပြေတဲ့ ပစ္စည်းတွေ။ 
စျေးနဲ့ availability

နောက်တစ်ခုက ဒီမှာ Encraving ရတယ်။ ဒါကလည်း iPad Pro ဝယ်ဖို့အတွက် တွန်းအားတစ်ခုပဲ။

စိတ်ထဲမှာတော့ iPad Pro က အားသာနေတယ်။
ဒါသုံးပြီး လုပ်ငန်းအရ အထောက်အကူပြုမှာလားဆိုတာကတော့ သိပ်ပြီး ထိရောက်မှာ မဟုတ်ဘူး။

iPad Pro အရင်ဝယ်ပြီး နောက်လမှ Mac Mini ဝယ်ရင်ကောင်းမလား?
ဒါကတော့ ဘုရင့်နောင် ဖောင်ဖျတ်တဲ့ ကိန်းပဲ။

256 SSD တစ်ခုလည်း ဝယ်ရမယ်။
SanDisk က ထုတ်တာလေး စျေးလည်းမဆိုးဘူး။ Design ကလည်း Type C နဲ့ Type A နှစ်ခုလုံးပါတော့ မိုဘိုင်းရော ကွန်ပျူတာရော အဆင်ပြေမယ့် သဘော။

Mac Mini က M2 စောင့်လိုက်ပြီး M2 ပါတဲ့ iPad Pro အရင်ဝယ်လိုက်မယ်။ :D

KM ❤️ MSD
2022-02-04

// TODO: make video about ordering ipad pro in india with Graving

အိုကေ 80,000 တန် iPad Pro တစ်လုံး ဝယ်မယ်။

mahar-by-ksmt 
ဒါကတော့ အိမ်အတွက် ရည်ရွယ်ထားလိုက်မယ်။
သိန်း (၃၀) တစ်လ ၊
နာရီပေါင်း ၂၄၀ =

လုပ်နိုင်တယ်လို့ အရင်ယုံထားရမယ်။
လိုချင်တာတွေကတော့ အများကြီးပေါ့။ 
စိတ်တွေတောင် နောက်ကျိသွားဉီးမယ်။
တစ်ခုချင်းစီကို အာရုံစိုက်ပြီးလုပ်ပါ။
ရှောင်သင့်တာတွေရှောင်။
စိတ်ကလေးကို တစ်ခုတည်းမှာ စူးစိုက်ပြီး အလုပ်လုပ်။

ကျွဲကူးရေပါ ဖြစ်အောင်က 
Chat ကို MAP မှာ ထည့်ပေးရမယ်။

comment စနစ် အရင်ထည့်ရမယ်။

wordpress မှာ မတွဲဘဲ ဒီ app တစ်ခုလုံးအတွက် သီးသန့် စနစ်တစ်ခု လုပ်ထားရမယ်။

database က နှစ်ခု ဖြစ်နေမယ်။
wordpress က အဖွဲ့တွေက Server to Server API နဲ့ ပြောရမယ့် သဘောမှာ ရှိမယ်။ data ယူတာ ထည့်တာ နဲ့ ပတ်သက်ပြီ။ data ထည့်တာကတော့ client ဘက်က တိုက်ရိုက်လုပ်လို့ရမယ်။ data ထုတ်တဲ့နေရာမှာ wordpress ကနေ ဒီဘက်က chat-solution ကို api ကနေပဲ လှမ်းမေးရမယ်။

User Account

ကိုယ်ပိုင် email , password နဲ့ ပဲ အရင် register လုပ်ခိုင်းမယ်။
နောက်ပိုင်းမှာ firebase auth နဲ့ verification လုပ်တာမျိုးတွေ လုပ်မယ်။

Public Chatroom

စာ၊ ပုံ , Video , Audio , File အကုန်ပို့နိုင်မယ်။
လောလောဆယ် ဖိုင် size ကို limit လုပ်ထားမယ်။

one to one chat

message

from user_id
to user_id | group_id
type one_to_one | group

What are we doing?

books in map-by-kmt

that’s also great.

flutter-dev

from zero to hero

This Evening

  OOAK -&gt; filter and pagination with query builder for multiple filter


POS

Chat Solution

  ui layout
  Basic Entity


mahar-by-ksmt

  firebase realtime - database


100 - 5 USD / month

5 * 3000 =&gt; 15,000 per month

User တစ်ရာကို 15,000

User တစ်ယောက်ကို 150 လောက် ကျမယ်။
ဒါက server ဖိုး။

Cloud Function နဲ့ Realtime Database ဒါပဲ သုံးမယ်။

architecture အရတော့

Admin Mobile နဲ့
Client Mobile သွားမယ်။

Firebase Realtime Database

JSON တစ်ခုပဲ။

Flutter မှာ ဘယ်လိုလုပ်ကြမလဲ?

install firebase_core in flutter
add init code in main()

firebase console မှာ realtime database တစ်ခု create လုပ်။ 
test mode ဖွင့်ထား
နောက်ပိုင်းမှာ Locked Mode ဖွင့်ထားမယ်။ client တွေစီက write request တွေ လက်မခံပဲ ကိုယ်သတ်မှတ်တဲ့ server က လာတဲ့ operation တွေကိုပဲ လက်ခံမယ့် သဘော။

install firebase_database package in flutter

FirebaseDatabase database = FirebaseDatabase.instance;
DatabaseReference ref = FirebaseDatabas.instance.ref("users/123");
// write , overwrite all key and value
await ref.set(
    {
        "name": "John"
    }
);

// update name, leave age, and sex with old data
await ref.set(
    {
        "name": "John"
    }
);

/* နားမလည်တာက path ဆိုတာ ဘာလဲ? */
/* JSON Key ကို ပြောချင်တာလား ? */
DatabaseReference ref = FirebaseDatabas.instance.ref("users");
await ref.update({
    "123/age": 19,
    "123/address/line1": "1 Mountain View"
});

/* listening data changes */
/* make sure closet level of data , don't listen root database instance */
DatabaseReference starCountRef = FirebaseDatabase.instance.ref("posts/$postId/starCount");
starCountRef.onValue.listen((DatabaseEvent event){
    final data = event.snapshot.value;
    updateStarCount(data);
    /* 
        event.snapshot.exists =&gt; true or false
        event.snapshot =&gt; may be null
    */

});

/* read once from remote / local */
final ref = FirebaseDatabase.instance.ref();
final snapshot = await ref.child('users/$userId').get(); // get from remote, if not find local 
if(snapshot.exists){
    print(snapshot.value);
}
else{
    print("No data availbale");
}

// တကယ်ကို တစ်ခါတည်း ဖတ်မှာ၊ ပြီးတော့ local ကနေ ချက်ခြင်းလိုချင်တာမျိုး
final event = await ref.once(DatabaseEventType.value);
final username = event.snapshot.value?.username ?? "Anonymous";

// insert and updating
void writeNewPost(String uid, String username, String picture, String title, String body){
    final postData = {
        'author' : username,
        'uid' : uid,
        'body' : body,
        'title' : title,
        'starCount' : 0,
        'authorPic' : picture,
    };

    // Get a key for a new post
    // .push() create new child
    // .key retrieve of newly created child
    // ဒီ key ကိုပဲ user-post မှာ ပြန်သုံးမယ်။
    final newPostKey = FirebaseDatabase.instance.ref().child('posts').push().key;
    // update in two paths
    final Map&lt;String, Map&gt; updates = {};
    /* u know, it's not linking, it's storing duplicate things */
    updates['/posts/$newPostKey'] = postData;
    updates['/user-posts/$uid/$newsPostKey'] = postData;
    // ဒါက update အားလုံး failed ရင် failed ဒါမှမဟုတ် အကုန် success ပြမယ်။ actomicity ဆိုပါတော့ ။
    return FirebaseDatabase.instance.ref().update(updates);

    /* set / update callback functions */
    FirebaseDatabase.instance
        .ref('users/$userId/email')
        .set(updateEmailAddress)
        .then((_){
            // data saved successfully
        })
        .catchError((error){
            // The write failed ...
        })
    );

    // ဖျတ်မယ်ဆိုရင် delete()

    // auto increment သုံးချင်ရင်
    // ServerValue.increment(1);
    updates["posts/$postId/startCount"] = ServerValue.increment(1);
}


data စပြီး ဘယ်လို ဖတ်မလဲ?

လက်ရှိ record တစ်ခုတည်းကို ဖတ်ရုံပဲ။

name
first_digit
second_digit
final_digit

data structure ကို တက်နိုင်သမျှ nested မသုံးပဲ flat ဖြစ်နိုင်သမျှ ဖြစ်အောင်ထား။

read တွေ write တွေက auth user တွေကိုပဲ ပေးလုပ်တာ များတယ်။
ဒီတော့ firebase auth ပါ လိုလာမယ်။

String, boolean, int , double, Map, List သုံးလို့ရမယ်။

{

}


တက်နိုင်သမျှ key value တွေသာသုံး

Data Structure for mahar-by-ksmt

အကုန်လုံးက Json Object တစ်ခုတည်းမှာ ထည့်ထားမှာ ဆိုတော့ level one ရဲ့ key တွေက Table သဘောမျိုး ဖြစ်နေမယ်။
array မသုံးပဲ key-&gt;value pair တွေချည်းသုံးတာ ကောင်းမယ်။ undefined index မဖြစ်တော့ပဲ key မရှိတောင် null ဖြစ်နေတာမျိုး။

ER Diagram

အဓိက သုံးမယ့် Entity တွေက


  User
  Intake


လောလောဆယ်တော့ ဒီ (၂) ခုပဲ။

User ကလည်း လောလောဆယ် Firebase Auth မသုံးသေးတော့ အိုကေတယ်။

အိုကေ ဒီတော့ Intake ကိုပဲ စဉ်းစားကြတာပေါ့။

Intake


  _id
  date
  time
  digit
  name : Intake Name Object


တစ်ခုရှိတာက name ကလည်း မျိုးစုံ ဖြစ်နိုင်တယ်။

IntakeName

  _id
  name


User

  _id
  email
  name
  profile_pic_url


Bet

  _id
  digit
  intake
  user


ဒါကိုပဲ array တစ်ခုတည်းမှာ သိမ်းထားရင် ရပြီ။

Lucky

  _id
  digit
  intake


ဒါလည်း အိုကေပြီ ထင်တယ်။

Data တိုင်းကတော့ store လုပ်ပြီးသွားပြီ။

Report အပိုင်းနဲ့ အလျော်အစားပဲ ကျန်မယ်။

ပထမ Report အတွက်က Aggregrate Function နဲ့ Filter တွေ လိုမယ်။ နောက်ပြီး pagination ဘယ်လိုလုပ်လဲ ကြည့်ရမယ်။
data တွေကတော့ နေရာအစုံမှာ duplicate လုပ်မယ်ဆိုတာ သိထားပါ။

ဒါမှ မဟုတ် aggregrate မလုပ်ပဲ တိုက်ရိုက်တွက်ထားတာက ဒီဘက်မှာ ပိုအဆင်ပြေမလား?

ပထမဆုံး ကြည့်မှာက အခု intake မှာ ဘယ်ဂဏန်းတွေ ဘယ်လောက် ထိုးထားပြီးပြီလဲ?

{
    "bet_reports" : {
        "_intakeId" : {
            "0" : 20,
            "1" : 10,
            ...
            "99" : 150,
            "sum" : 2000,
            "lucky" : 55,
            "win" : 1500,
            "lose" : 500
        }
    }
}


path ကလည်း ဒါမျိုး ဖြစ်သွားမယ်။

bet_reports/_intakeId

realtime လည်း ဖြစ်မယ်။ နောက်ပြီး report လည်း ရေးထားပြီးသားဖြစ်မယ်။

ဒီအပေါ်က data ရရင် win / lose အခြေအနေကိုလည်း တိုက်ရိုက် ထုတ်ပြနိုင်နေမယ်။

Provider -&gt; Data Source တွေ ကြားထဲမှာပဲ stream သုံးပြီး Provider နဲ့ UI ကြားမှာတော့ NotifyListener အရင်အတိုင်း သွားကြတာပေါ့။

Provider &lt;-&gt; Repository ကြားမှာ က Clean Stream ဆိုလိုတာက Entity တွေပဲ သယ်ယူပို့ဆောင် လုပ်မယ်။
Repository &lt;-&gt; DataSource ကြားမှာလည်း အတူတူပဲ Clean Stream ကိုပဲ ဆက်သုံးမယ်။ ဒါပေမယ့် ဒီမှာ Failure ပြန်ကောင်း ပြန်လာမယ်။
DataSource &lt;-&gt; Firebase ကြားမှာတော့ Raw Stream ကို သုံးမယ်။ Raw Stream က ရလာတဲ့ Data ကို Clean လုပ်ပြီးမှ Repository အတွက် Clean Stream ကနေ Entity တွေ ပို့ပေးမယ်။ 
အဲ့မှာ Repository ကနေ Usecase က တဆင့် Data တွေကို Stream နဲ့ ထပ်ပို့ပေးမယ်။

abstract class MaharRepository{
    /* User Login အပိုင်းက UI တွေလည်း ပါတာဆိုတော့ ဘယ်လိုလုပ်ကြမလဲ? Provider နဲ့ UI အကြားမှာပဲ ထားမလား? */
    Future&lt;Stream&lt;Intake&gt;, Failure&gt; getCurrentIntake({required String accessToken});
    // ဒါက admin အတွက်ပဲ။
    Future&lt;String, Failure&gt; setCurrentIntake({required String accessToken, required Intake intake});

    Future&lt;List&lt;Intake&gt;, Failure&gt; getIntakeListByDate({required String accessToken, required Date date});
    Future&lt;List&lt;Gift&gt;, Failure&gt; getGiftListByDate({required String accessToken, required Date date});
}

အခု အခြေအနေအရတော့ Repository က အဓိက အကျဆုံးပဲ။

ပြီးမှ  Usecase ပေါ့ ။

Outline ရဖို့က Repository ရေးရင် ရပြီ။
အမှန်ကတော့ Use Case တွေ တန်းစီပြီး ချရေးရမှာ။

အိုကေ UseCase ဆိုပါတော့

ဆိုတော့ကာ လေလေ

Flatering the data structure

တက်နိုင်သမျှ nest နေကြတာ ကျွန်တော်တို့အတွက် Google က အကြံပေးတဲ့  Flat Datastructure က အတော်လေး ထူးဆန်းတယ်။

List ထဲကို data append လုပ်မယ်
DatabaseReference postListRef = FirebaseDatabase.instance.ref("posts");
DatabaseReference newPostRef = postListRef.push();
newPostRef.set({

});


Children တွေရဲ့ Event တွေကို ဘယ်လို listen လုပ်ကြမလဲ

collection တစ်ခုလုံးကို Listen လုပ်တာ မလုပ်ပဲ။ append လုပ်တာ။ update လုပ်တာ။ remove လုပ်တာလောက်ကိုပဲ တိတိကျကျ listen လုပ်ထားရင် ပိုပြီး effecient ဖြစ်တာပေါ့။

nested json တွေ အကုန်လုံးက path အနေနဲ့ သွားတာ။

final commentRef = FirebaseDatabase.instance.ref("post-comments/$postId");
commentRef.onChildAdded.listen((event){
    // a new comment has been added
});
commentRef.onChildChanged.listen((event){
    // a comment has changed
});
commentRef.onChildRemoved.listen((event){
    // a comment has been removed
});


ဒါက sorting အပိုင်း
final myUserId = FirebaseAuth.instance.currentUser?.uid;
final topUserPostsRef = FirebaseDatabase.instance.ref("user-posts/$myUserId").orderByChild("starCount");


for nested json
{
    "posts":{
        "ts-functions":{
            "metrics":{
                "views" : 100,
                "likes" : 25000
            },
            "title": "Why we should use TypeScript?",
            "description" : "blah blah blah blah "
        },
        "node-js":{
            "metrics":{
                "views" : 502,
                "likes" : 65203
            },
            "title": "Node : The fall of JS",
            "description" : "blah blah blah blah "
        }
    }
}

final mostViewedPosts = FirebaseDatabase.instance.ref("posts").orderByChild("metrics/views");

// orderByChild
// orderByKey
// orderByValue

/* We can use only one order by cretia */


Filter ဘယ်လိုလုပ်မလဲ?

// limitToFirst
// limitToLast
// startAt
// startAfter
// endAt
// endBefore
// equalTo

final recentPostsRef = FirebaseDatabase.instance.ref('posts').limitToLast(100);



** ရှာတာ ဖွေတာ မရဘူး ***
list နဲ့ ဆွဲထုတ်ရင်တော့ ရမယ်။

orderBy မှာ date ဘာညာသာရကာ သုံးလဲ sorting အတွက်ပဲ။
အိုကေ sorting အတွက် လုပ်တဲ့ နေရာမှာ where clause လို့ သဘောထားလို့တော့ ရမယ်။
မရဘူးပဲ။ where clause မှာက equal to ပါတယ်။ 
sorting / orderBy မှာက field name တစ်ခုပဲ ပါတာ။

filter မှာတော့ equalTo ဆိုတဲ့ emthod ပါတယ်။
ကိုယ်လိုချင်တဲ့ where clause သုံးလို့ရမလား ကြည့်ရအောင်။

ရပြီ
dinosaursRef.orderByChild("height").equalTo(25); 

ဆိုတော့ကာ orderByChild နဲ့ equalTo ကို သုံးပြီး လိုချင်တဲ့ row အတိအကျကို filter လုပ်လို့ရမယ်။

pagination လိုချင်ရင် 
offset အနေနဲ့ .startAfter
limit အနေနဲ့ .limitToFirst

ဆိုပါတော့ ကိုယ်က

user ရဲ့ တစ်ရက်စာ bet list ကို ထုတ်ကြည့်ချင်တယ်။

သိမ်းထားတဲ့ ပုံစံက ဒါမျိုး ဖြစ်မယ်။

user-bets

{
    "user-bets" : {
        "user_id" : {
            "intake_id": {
                "bet_id" : {
                    // bet object
                },
                "bet_id2" : {
                    // bet object
                }
            }
        }
    }
}


@ input

  userId
  date


ပြန်လာရမှာက List




" />
    <meta property="og:description" content="What are we doing for things we want?

Mac Mini ဝယ်ရမလား 
iPad Pro ဝယ်ရမလား?

အလုပ်အတွက်ကတော့ Mac Mini က ပိုကောင်းတယ်။ ပိုပြီးအသုံးဝင်မယ်။
iPad Pro ကတော့ ကိုယ့်ရဲ့ အာသီသအတွက်။
အလုပ်အတွက်လည်း အနည်းနဲ့အများ အထောက်အကူပြုမယ်ဆိုပေမယ့် Mac Mini နဲ့ တော့ မယှဉ်သာဘူး။

နှစ်ခုလုံး ဝယ်နိုင်အောင် လုပ်တာပေါ့။

MAP-BY-KMT က Ads ကိစ္စ ပြီးရင် အကုန်ပြီးပြီ ပြောရမယ်။

iPad Pro အတွက်က Movie Streaming ကို အာရုံစိုက်ရမှာပေါ့ ။ ဒီ Janaray တစ်လ အာရုံစိုက်ပြီးလုပ်ရင် ရမယ်ထင်တယ်။

iPad Pro က instance pleasure ကို ရမယ်။
second screen ရမယ်။
pan နဲ့ ဘာနဲ့ စာသင်တဲ့အခါ အဆင်ပြေကောင်း ပိုပြေလာမယ်။

mac mini ကတော့ ပြန်ရောက်တဲ့အခါ ပိုပြီး Professional ဆန်လာမယ်။

နှစ်ခုလုံးကတော့ မြန်မာနိုင်ငံမှာဆို ဝယ်ဖို့ အဆင်မပြေတဲ့ ပစ္စည်းတွေ။ 
စျေးနဲ့ availability

နောက်တစ်ခုက ဒီမှာ Encraving ရတယ်။ ဒါကလည်း iPad Pro ဝယ်ဖို့အတွက် တွန်းအားတစ်ခုပဲ။

စိတ်ထဲမှာတော့ iPad Pro က အားသာနေတယ်။
ဒါသုံးပြီး လုပ်ငန်းအရ အထောက်အကူပြုမှာလားဆိုတာကတော့ သိပ်ပြီး ထိရောက်မှာ မဟုတ်ဘူး။

iPad Pro အရင်ဝယ်ပြီး နောက်လမှ Mac Mini ဝယ်ရင်ကောင်းမလား?
ဒါကတော့ ဘုရင့်နောင် ဖောင်ဖျတ်တဲ့ ကိန်းပဲ။

256 SSD တစ်ခုလည်း ဝယ်ရမယ်။
SanDisk က ထုတ်တာလေး စျေးလည်းမဆိုးဘူး။ Design ကလည်း Type C နဲ့ Type A နှစ်ခုလုံးပါတော့ မိုဘိုင်းရော ကွန်ပျူတာရော အဆင်ပြေမယ့် သဘော။

Mac Mini က M2 စောင့်လိုက်ပြီး M2 ပါတဲ့ iPad Pro အရင်ဝယ်လိုက်မယ်။ :D

KM ❤️ MSD
2022-02-04

// TODO: make video about ordering ipad pro in india with Graving

အိုကေ 80,000 တန် iPad Pro တစ်လုံး ဝယ်မယ်။

mahar-by-ksmt 
ဒါကတော့ အိမ်အတွက် ရည်ရွယ်ထားလိုက်မယ်။
သိန်း (၃၀) တစ်လ ၊
နာရီပေါင်း ၂၄၀ =

လုပ်နိုင်တယ်လို့ အရင်ယုံထားရမယ်။
လိုချင်တာတွေကတော့ အများကြီးပေါ့။ 
စိတ်တွေတောင် နောက်ကျိသွားဉီးမယ်။
တစ်ခုချင်းစီကို အာရုံစိုက်ပြီးလုပ်ပါ။
ရှောင်သင့်တာတွေရှောင်။
စိတ်ကလေးကို တစ်ခုတည်းမှာ စူးစိုက်ပြီး အလုပ်လုပ်။

ကျွဲကူးရေပါ ဖြစ်အောင်က 
Chat ကို MAP မှာ ထည့်ပေးရမယ်။

comment စနစ် အရင်ထည့်ရမယ်။

wordpress မှာ မတွဲဘဲ ဒီ app တစ်ခုလုံးအတွက် သီးသန့် စနစ်တစ်ခု လုပ်ထားရမယ်။

database က နှစ်ခု ဖြစ်နေမယ်။
wordpress က အဖွဲ့တွေက Server to Server API နဲ့ ပြောရမယ့် သဘောမှာ ရှိမယ်။ data ယူတာ ထည့်တာ နဲ့ ပတ်သက်ပြီ။ data ထည့်တာကတော့ client ဘက်က တိုက်ရိုက်လုပ်လို့ရမယ်။ data ထုတ်တဲ့နေရာမှာ wordpress ကနေ ဒီဘက်က chat-solution ကို api ကနေပဲ လှမ်းမေးရမယ်။

User Account

ကိုယ်ပိုင် email , password နဲ့ ပဲ အရင် register လုပ်ခိုင်းမယ်။
နောက်ပိုင်းမှာ firebase auth နဲ့ verification လုပ်တာမျိုးတွေ လုပ်မယ်။

Public Chatroom

စာ၊ ပုံ , Video , Audio , File အကုန်ပို့နိုင်မယ်။
လောလောဆယ် ဖိုင် size ကို limit လုပ်ထားမယ်။

one to one chat

message

from user_id
to user_id | group_id
type one_to_one | group

What are we doing?

books in map-by-kmt

that’s also great.

flutter-dev

from zero to hero

This Evening

  OOAK -&gt; filter and pagination with query builder for multiple filter


POS

Chat Solution

  ui layout
  Basic Entity


mahar-by-ksmt

  firebase realtime - database


100 - 5 USD / month

5 * 3000 =&gt; 15,000 per month

User တစ်ရာကို 15,000

User တစ်ယောက်ကို 150 လောက် ကျမယ်။
ဒါက server ဖိုး။

Cloud Function နဲ့ Realtime Database ဒါပဲ သုံးမယ်။

architecture အရတော့

Admin Mobile နဲ့
Client Mobile သွားမယ်။

Firebase Realtime Database

JSON တစ်ခုပဲ။

Flutter မှာ ဘယ်လိုလုပ်ကြမလဲ?

install firebase_core in flutter
add init code in main()

firebase console မှာ realtime database တစ်ခု create လုပ်။ 
test mode ဖွင့်ထား
နောက်ပိုင်းမှာ Locked Mode ဖွင့်ထားမယ်။ client တွေစီက write request တွေ လက်မခံပဲ ကိုယ်သတ်မှတ်တဲ့ server က လာတဲ့ operation တွေကိုပဲ လက်ခံမယ့် သဘော။

install firebase_database package in flutter

FirebaseDatabase database = FirebaseDatabase.instance;
DatabaseReference ref = FirebaseDatabas.instance.ref("users/123");
// write , overwrite all key and value
await ref.set(
    {
        "name": "John"
    }
);

// update name, leave age, and sex with old data
await ref.set(
    {
        "name": "John"
    }
);

/* နားမလည်တာက path ဆိုတာ ဘာလဲ? */
/* JSON Key ကို ပြောချင်တာလား ? */
DatabaseReference ref = FirebaseDatabas.instance.ref("users");
await ref.update({
    "123/age": 19,
    "123/address/line1": "1 Mountain View"
});

/* listening data changes */
/* make sure closet level of data , don't listen root database instance */
DatabaseReference starCountRef = FirebaseDatabase.instance.ref("posts/$postId/starCount");
starCountRef.onValue.listen((DatabaseEvent event){
    final data = event.snapshot.value;
    updateStarCount(data);
    /* 
        event.snapshot.exists =&gt; true or false
        event.snapshot =&gt; may be null
    */

});

/* read once from remote / local */
final ref = FirebaseDatabase.instance.ref();
final snapshot = await ref.child('users/$userId').get(); // get from remote, if not find local 
if(snapshot.exists){
    print(snapshot.value);
}
else{
    print("No data availbale");
}

// တကယ်ကို တစ်ခါတည်း ဖတ်မှာ၊ ပြီးတော့ local ကနေ ချက်ခြင်းလိုချင်တာမျိုး
final event = await ref.once(DatabaseEventType.value);
final username = event.snapshot.value?.username ?? "Anonymous";

// insert and updating
void writeNewPost(String uid, String username, String picture, String title, String body){
    final postData = {
        'author' : username,
        'uid' : uid,
        'body' : body,
        'title' : title,
        'starCount' : 0,
        'authorPic' : picture,
    };

    // Get a key for a new post
    // .push() create new child
    // .key retrieve of newly created child
    // ဒီ key ကိုပဲ user-post မှာ ပြန်သုံးမယ်။
    final newPostKey = FirebaseDatabase.instance.ref().child('posts').push().key;
    // update in two paths
    final Map&lt;String, Map&gt; updates = {};
    /* u know, it's not linking, it's storing duplicate things */
    updates['/posts/$newPostKey'] = postData;
    updates['/user-posts/$uid/$newsPostKey'] = postData;
    // ဒါက update အားလုံး failed ရင် failed ဒါမှမဟုတ် အကုန် success ပြမယ်။ actomicity ဆိုပါတော့ ။
    return FirebaseDatabase.instance.ref().update(updates);

    /* set / update callback functions */
    FirebaseDatabase.instance
        .ref('users/$userId/email')
        .set(updateEmailAddress)
        .then((_){
            // data saved successfully
        })
        .catchError((error){
            // The write failed ...
        })
    );

    // ဖျတ်မယ်ဆိုရင် delete()

    // auto increment သုံးချင်ရင်
    // ServerValue.increment(1);
    updates["posts/$postId/startCount"] = ServerValue.increment(1);
}


data စပြီး ဘယ်လို ဖတ်မလဲ?

လက်ရှိ record တစ်ခုတည်းကို ဖတ်ရုံပဲ။

name
first_digit
second_digit
final_digit

data structure ကို တက်နိုင်သမျှ nested မသုံးပဲ flat ဖြစ်နိုင်သမျှ ဖြစ်အောင်ထား။

read တွေ write တွေက auth user တွေကိုပဲ ပေးလုပ်တာ များတယ်။
ဒီတော့ firebase auth ပါ လိုလာမယ်။

String, boolean, int , double, Map, List သုံးလို့ရမယ်။

{

}


တက်နိုင်သမျှ key value တွေသာသုံး

Data Structure for mahar-by-ksmt

အကုန်လုံးက Json Object တစ်ခုတည်းမှာ ထည့်ထားမှာ ဆိုတော့ level one ရဲ့ key တွေက Table သဘောမျိုး ဖြစ်နေမယ်။
array မသုံးပဲ key-&gt;value pair တွေချည်းသုံးတာ ကောင်းမယ်။ undefined index မဖြစ်တော့ပဲ key မရှိတောင် null ဖြစ်နေတာမျိုး။

ER Diagram

အဓိက သုံးမယ့် Entity တွေက


  User
  Intake


လောလောဆယ်တော့ ဒီ (၂) ခုပဲ။

User ကလည်း လောလောဆယ် Firebase Auth မသုံးသေးတော့ အိုကေတယ်။

အိုကေ ဒီတော့ Intake ကိုပဲ စဉ်းစားကြတာပေါ့။

Intake


  _id
  date
  time
  digit
  name : Intake Name Object


တစ်ခုရှိတာက name ကလည်း မျိုးစုံ ဖြစ်နိုင်တယ်။

IntakeName

  _id
  name


User

  _id
  email
  name
  profile_pic_url


Bet

  _id
  digit
  intake
  user


ဒါကိုပဲ array တစ်ခုတည်းမှာ သိမ်းထားရင် ရပြီ။

Lucky

  _id
  digit
  intake


ဒါလည်း အိုကေပြီ ထင်တယ်။

Data တိုင်းကတော့ store လုပ်ပြီးသွားပြီ။

Report အပိုင်းနဲ့ အလျော်အစားပဲ ကျန်မယ်။

ပထမ Report အတွက်က Aggregrate Function နဲ့ Filter တွေ လိုမယ်။ နောက်ပြီး pagination ဘယ်လိုလုပ်လဲ ကြည့်ရမယ်။
data တွေကတော့ နေရာအစုံမှာ duplicate လုပ်မယ်ဆိုတာ သိထားပါ။

ဒါမှ မဟုတ် aggregrate မလုပ်ပဲ တိုက်ရိုက်တွက်ထားတာက ဒီဘက်မှာ ပိုအဆင်ပြေမလား?

ပထမဆုံး ကြည့်မှာက အခု intake မှာ ဘယ်ဂဏန်းတွေ ဘယ်လောက် ထိုးထားပြီးပြီလဲ?

{
    "bet_reports" : {
        "_intakeId" : {
            "0" : 20,
            "1" : 10,
            ...
            "99" : 150,
            "sum" : 2000,
            "lucky" : 55,
            "win" : 1500,
            "lose" : 500
        }
    }
}


path ကလည်း ဒါမျိုး ဖြစ်သွားမယ်။

bet_reports/_intakeId

realtime လည်း ဖြစ်မယ်။ နောက်ပြီး report လည်း ရေးထားပြီးသားဖြစ်မယ်။

ဒီအပေါ်က data ရရင် win / lose အခြေအနေကိုလည်း တိုက်ရိုက် ထုတ်ပြနိုင်နေမယ်။

Provider -&gt; Data Source တွေ ကြားထဲမှာပဲ stream သုံးပြီး Provider နဲ့ UI ကြားမှာတော့ NotifyListener အရင်အတိုင်း သွားကြတာပေါ့။

Provider &lt;-&gt; Repository ကြားမှာ က Clean Stream ဆိုလိုတာက Entity တွေပဲ သယ်ယူပို့ဆောင် လုပ်မယ်။
Repository &lt;-&gt; DataSource ကြားမှာလည်း အတူတူပဲ Clean Stream ကိုပဲ ဆက်သုံးမယ်။ ဒါပေမယ့် ဒီမှာ Failure ပြန်ကောင်း ပြန်လာမယ်။
DataSource &lt;-&gt; Firebase ကြားမှာတော့ Raw Stream ကို သုံးမယ်။ Raw Stream က ရလာတဲ့ Data ကို Clean လုပ်ပြီးမှ Repository အတွက် Clean Stream ကနေ Entity တွေ ပို့ပေးမယ်။ 
အဲ့မှာ Repository ကနေ Usecase က တဆင့် Data တွေကို Stream နဲ့ ထပ်ပို့ပေးမယ်။

abstract class MaharRepository{
    /* User Login အပိုင်းက UI တွေလည်း ပါတာဆိုတော့ ဘယ်လိုလုပ်ကြမလဲ? Provider နဲ့ UI အကြားမှာပဲ ထားမလား? */
    Future&lt;Stream&lt;Intake&gt;, Failure&gt; getCurrentIntake({required String accessToken});
    // ဒါက admin အတွက်ပဲ။
    Future&lt;String, Failure&gt; setCurrentIntake({required String accessToken, required Intake intake});

    Future&lt;List&lt;Intake&gt;, Failure&gt; getIntakeListByDate({required String accessToken, required Date date});
    Future&lt;List&lt;Gift&gt;, Failure&gt; getGiftListByDate({required String accessToken, required Date date});
}

အခု အခြေအနေအရတော့ Repository က အဓိက အကျဆုံးပဲ။

ပြီးမှ  Usecase ပေါ့ ။

Outline ရဖို့က Repository ရေးရင် ရပြီ။
အမှန်ကတော့ Use Case တွေ တန်းစီပြီး ချရေးရမှာ။

အိုကေ UseCase ဆိုပါတော့

ဆိုတော့ကာ လေလေ

Flatering the data structure

တက်နိုင်သမျှ nest နေကြတာ ကျွန်တော်တို့အတွက် Google က အကြံပေးတဲ့  Flat Datastructure က အတော်လေး ထူးဆန်းတယ်။

List ထဲကို data append လုပ်မယ်
DatabaseReference postListRef = FirebaseDatabase.instance.ref("posts");
DatabaseReference newPostRef = postListRef.push();
newPostRef.set({

});


Children တွေရဲ့ Event တွေကို ဘယ်လို listen လုပ်ကြမလဲ

collection တစ်ခုလုံးကို Listen လုပ်တာ မလုပ်ပဲ။ append လုပ်တာ။ update လုပ်တာ။ remove လုပ်တာလောက်ကိုပဲ တိတိကျကျ listen လုပ်ထားရင် ပိုပြီး effecient ဖြစ်တာပေါ့။

nested json တွေ အကုန်လုံးက path အနေနဲ့ သွားတာ။

final commentRef = FirebaseDatabase.instance.ref("post-comments/$postId");
commentRef.onChildAdded.listen((event){
    // a new comment has been added
});
commentRef.onChildChanged.listen((event){
    // a comment has changed
});
commentRef.onChildRemoved.listen((event){
    // a comment has been removed
});


ဒါက sorting အပိုင်း
final myUserId = FirebaseAuth.instance.currentUser?.uid;
final topUserPostsRef = FirebaseDatabase.instance.ref("user-posts/$myUserId").orderByChild("starCount");


for nested json
{
    "posts":{
        "ts-functions":{
            "metrics":{
                "views" : 100,
                "likes" : 25000
            },
            "title": "Why we should use TypeScript?",
            "description" : "blah blah blah blah "
        },
        "node-js":{
            "metrics":{
                "views" : 502,
                "likes" : 65203
            },
            "title": "Node : The fall of JS",
            "description" : "blah blah blah blah "
        }
    }
}

final mostViewedPosts = FirebaseDatabase.instance.ref("posts").orderByChild("metrics/views");

// orderByChild
// orderByKey
// orderByValue

/* We can use only one order by cretia */


Filter ဘယ်လိုလုပ်မလဲ?

// limitToFirst
// limitToLast
// startAt
// startAfter
// endAt
// endBefore
// equalTo

final recentPostsRef = FirebaseDatabase.instance.ref('posts').limitToLast(100);



** ရှာတာ ဖွေတာ မရဘူး ***
list နဲ့ ဆွဲထုတ်ရင်တော့ ရမယ်။

orderBy မှာ date ဘာညာသာရကာ သုံးလဲ sorting အတွက်ပဲ။
အိုကေ sorting အတွက် လုပ်တဲ့ နေရာမှာ where clause လို့ သဘောထားလို့တော့ ရမယ်။
မရဘူးပဲ။ where clause မှာက equal to ပါတယ်။ 
sorting / orderBy မှာက field name တစ်ခုပဲ ပါတာ။

filter မှာတော့ equalTo ဆိုတဲ့ emthod ပါတယ်။
ကိုယ်လိုချင်တဲ့ where clause သုံးလို့ရမလား ကြည့်ရအောင်။

ရပြီ
dinosaursRef.orderByChild("height").equalTo(25); 

ဆိုတော့ကာ orderByChild နဲ့ equalTo ကို သုံးပြီး လိုချင်တဲ့ row အတိအကျကို filter လုပ်လို့ရမယ်။

pagination လိုချင်ရင် 
offset အနေနဲ့ .startAfter
limit အနေနဲ့ .limitToFirst

ဆိုပါတော့ ကိုယ်က

user ရဲ့ တစ်ရက်စာ bet list ကို ထုတ်ကြည့်ချင်တယ်။

သိမ်းထားတဲ့ ပုံစံက ဒါမျိုး ဖြစ်မယ်။

user-bets

{
    "user-bets" : {
        "user_id" : {
            "intake_id": {
                "bet_id" : {
                    // bet object
                },
                "bet_id2" : {
                    // bet object
                }
            }
        }
    }
}


@ input

  userId
  date


ပြန်လာရမှာက List




" />
    
    <meta name="author" content="" />

    
    <meta property="og:title" content="What are we doing for things we want?" />
    <meta property="twitter:title" content="What are we doing for things we want?" />
    

    <!-- facebook Open Graph Metadatas -->
    <meta content="your_facebook_app_id" property="fb:app_id">
    <meta content="Your awesome title" property="og:site_name">
    
    <meta content="What are we doing for things we want?" property="og:title">
    
    
    <meta content="article" property="og:type">
    
    
    <meta content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." property="og:description">
    
    
    <meta content="http://localhost:4000/2022/12/31/what-are-we-doing-for-things-we-want.html" property="og:url">
    
    
    <meta content="2022-12-31T00:00:00+06:30" property="article:published_time">
    <meta content="http://localhost:4000/about/" property="article:author">
    
    
    <meta content="/img/logo-high-resolution.png" property="og:image">
    
    
    
    
    
    
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title=" - Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/"></a></h1>
            <p class="site-description">Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>What are we doing for things we want?</h1>

  <div class="entry">
    <h1 id="what-are-we-doing-for-things-we-want">What are we doing for things we want?</h1>

<p>Mac Mini ဝယ်ရမလား 
iPad Pro ဝယ်ရမလား?</p>

<p>အလုပ်အတွက်ကတော့ Mac Mini က ပိုကောင်းတယ်။ ပိုပြီးအသုံးဝင်မယ်။
iPad Pro ကတော့ ကိုယ့်ရဲ့ အာသီသအတွက်။
အလုပ်အတွက်လည်း အနည်းနဲ့အများ အထောက်အကူပြုမယ်ဆိုပေမယ့် Mac Mini နဲ့ တော့ မယှဉ်သာဘူး။</p>

<p>နှစ်ခုလုံး ဝယ်နိုင်အောင် လုပ်တာပေါ့။</p>

<p>MAP-BY-KMT က Ads ကိစ္စ ပြီးရင် အကုန်ပြီးပြီ ပြောရမယ်။</p>

<p>iPad Pro အတွက်က Movie Streaming ကို အာရုံစိုက်ရမှာပေါ့ ။ ဒီ Janaray တစ်လ အာရုံစိုက်ပြီးလုပ်ရင် ရမယ်ထင်တယ်။</p>

<p>iPad Pro က instance pleasure ကို ရမယ်။
second screen ရမယ်။
pan နဲ့ ဘာနဲ့ စာသင်တဲ့အခါ အဆင်ပြေကောင်း ပိုပြေလာမယ်။</p>

<p>mac mini ကတော့ ပြန်ရောက်တဲ့အခါ ပိုပြီး Professional ဆန်လာမယ်။</p>

<p>နှစ်ခုလုံးကတော့ မြန်မာနိုင်ငံမှာဆို ဝယ်ဖို့ အဆင်မပြေတဲ့ ပစ္စည်းတွေ။ 
စျေးနဲ့ availability</p>

<p>နောက်တစ်ခုက ဒီမှာ Encraving ရတယ်။ ဒါကလည်း iPad Pro ဝယ်ဖို့အတွက် တွန်းအားတစ်ခုပဲ။</p>

<p>စိတ်ထဲမှာတော့ iPad Pro က အားသာနေတယ်။
ဒါသုံးပြီး လုပ်ငန်းအရ အထောက်အကူပြုမှာလားဆိုတာကတော့ သိပ်ပြီး ထိရောက်မှာ မဟုတ်ဘူး။</p>

<p>iPad Pro အရင်ဝယ်ပြီး နောက်လမှ Mac Mini ဝယ်ရင်ကောင်းမလား?
ဒါကတော့ ဘုရင့်နောင် ဖောင်ဖျတ်တဲ့ ကိန်းပဲ။</p>

<p>256 SSD တစ်ခုလည်း ဝယ်ရမယ်။
SanDisk က ထုတ်တာလေး စျေးလည်းမဆိုးဘူး။ Design ကလည်း Type C နဲ့ Type A နှစ်ခုလုံးပါတော့ မိုဘိုင်းရော ကွန်ပျူတာရော အဆင်ပြေမယ့် သဘော။</p>

<p>Mac Mini က M2 စောင့်လိုက်ပြီး M2 ပါတဲ့ iPad Pro အရင်ဝယ်လိုက်မယ်။ :D</p>

<p>KM ❤️ MSD
2022-02-04</p>

<p>// TODO: make video about ordering ipad pro in india with Graving</p>

<p>အိုကေ 80,000 တန် iPad Pro တစ်လုံး ဝယ်မယ်။</p>

<p>mahar-by-ksmt 
ဒါကတော့ အိမ်အတွက် ရည်ရွယ်ထားလိုက်မယ်။
သိန်း (၃၀) တစ်လ ၊
နာရီပေါင်း ၂၄၀ =</p>

<p>လုပ်နိုင်တယ်လို့ အရင်ယုံထားရမယ်။
လိုချင်တာတွေကတော့ အများကြီးပေါ့။ 
စိတ်တွေတောင် နောက်ကျိသွားဉီးမယ်။
တစ်ခုချင်းစီကို အာရုံစိုက်ပြီးလုပ်ပါ။
ရှောင်သင့်တာတွေရှောင်။
စိတ်ကလေးကို တစ်ခုတည်းမှာ စူးစိုက်ပြီး အလုပ်လုပ်။</p>

<p>ကျွဲကူးရေပါ ဖြစ်အောင်က 
Chat ကို MAP မှာ ထည့်ပေးရမယ်။</p>

<p>comment စနစ် အရင်ထည့်ရမယ်။</p>

<p>wordpress မှာ မတွဲဘဲ ဒီ app တစ်ခုလုံးအတွက် သီးသန့် စနစ်တစ်ခု လုပ်ထားရမယ်။</p>

<p>database က နှစ်ခု ဖြစ်နေမယ်။
wordpress က အဖွဲ့တွေက Server to Server API နဲ့ ပြောရမယ့် သဘောမှာ ရှိမယ်။ data ယူတာ ထည့်တာ နဲ့ ပတ်သက်ပြီ။ data ထည့်တာကတော့ client ဘက်က တိုက်ရိုက်လုပ်လို့ရမယ်။ data ထုတ်တဲ့နေရာမှာ wordpress ကနေ ဒီဘက်က chat-solution ကို api ကနေပဲ လှမ်းမေးရမယ်။</p>

<p>User Account</p>

<p>ကိုယ်ပိုင် email , password နဲ့ ပဲ အရင် register လုပ်ခိုင်းမယ်။
နောက်ပိုင်းမှာ firebase auth နဲ့ verification လုပ်တာမျိုးတွေ လုပ်မယ်။</p>

<h2 id="public-chatroom">Public Chatroom</h2>

<p>စာ၊ ပုံ , Video , Audio , File အကုန်ပို့နိုင်မယ်။
လောလောဆယ် ဖိုင် size ကို limit လုပ်ထားမယ်။</p>

<h2 id="one-to-one-chat">one to one chat</h2>

<p>message</p>

<p>from user_id
to user_id | group_id
type one_to_one | group</p>

<h2 id="what-are-we-doing">What are we doing?</h2>

<p>books in map-by-kmt</p>

<p>that’s also great.</p>

<p>flutter-dev</p>

<p>from zero to hero</p>

<h3 id="this-evening">This Evening</h3>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />OOAK -&gt; filter and pagination with query builder for multiple filter</li>
</ul>

<h3 id="pos">POS</h3>

<h3 id="chat-solution">Chat Solution</h3>
<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />ui layout</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Basic Entity</li>
</ul>

<h3 id="mahar-by-ksmt">mahar-by-ksmt</h3>
<ul>
  <li>firebase realtime - database</li>
</ul>

<p>100 - 5 USD / month</p>

<p>5 * 3000 =&gt; 15,000 per month</p>

<p>User တစ်ရာကို 15,000</p>

<p>User တစ်ယောက်ကို 150 လောက် ကျမယ်။
ဒါက server ဖိုး။</p>

<p>Cloud Function နဲ့ Realtime Database ဒါပဲ သုံးမယ်။</p>

<p>architecture အရတော့</p>

<p>Admin Mobile နဲ့
Client Mobile သွားမယ်။</p>

<h3 id="firebase-realtime-database">Firebase Realtime Database</h3>

<p>JSON တစ်ခုပဲ။</p>

<h3 id="flutter-မှာ-ဘယ်လိုလုပ်ကြမလဲ">Flutter မှာ ဘယ်လိုလုပ်ကြမလဲ?</h3>

<p>install firebase_core in flutter
add init code in main()</p>

<p>firebase console မှာ realtime database တစ်ခု create လုပ်။ 
test mode ဖွင့်ထား
နောက်ပိုင်းမှာ Locked Mode ဖွင့်ထားမယ်။ client တွေစီက write request တွေ လက်မခံပဲ ကိုယ်သတ်မှတ်တဲ့ server က လာတဲ့ operation တွေကိုပဲ လက်ခံမယ့် သဘော။</p>

<p>install firebase_database package in flutter</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FirebaseDatabase</span> <span class="n">database</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="p">;</span>
<span class="n">DatabaseReference</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">FirebaseDatabas</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">"users/123"</span><span class="p">);</span>
<span class="c1">// write , overwrite all key and value</span>
<span class="k">await</span> <span class="n">ref</span><span class="o">.</span><span class="na">set</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s">"name"</span><span class="o">:</span> <span class="s">"John"</span>
    <span class="p">}</span>
<span class="p">);</span>

<span class="c1">// update name, leave age, and sex with old data</span>
<span class="k">await</span> <span class="n">ref</span><span class="o">.</span><span class="na">set</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="s">"name"</span><span class="o">:</span> <span class="s">"John"</span>
    <span class="p">}</span>
<span class="p">);</span>

<span class="cm">/* နားမလည်တာက path ဆိုတာ ဘာလဲ? */</span>
<span class="cm">/* JSON Key ကို ပြောချင်တာလား ? */</span>
<span class="n">DatabaseReference</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">FirebaseDatabas</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">"users"</span><span class="p">);</span>
<span class="k">await</span> <span class="n">ref</span><span class="o">.</span><span class="na">update</span><span class="p">({</span>
    <span class="s">"123/age"</span><span class="o">:</span> <span class="mi">19</span><span class="p">,</span>
    <span class="s">"123/address/line1"</span><span class="o">:</span> <span class="s">"1 Mountain View"</span>
<span class="p">});</span>

<span class="cm">/* listening data changes */</span>
<span class="cm">/* make sure closet level of data , don't listen root database instance */</span>
<span class="n">DatabaseReference</span> <span class="n">starCountRef</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">"posts/</span><span class="si">$postId</span><span class="s">/starCount"</span><span class="p">);</span>
<span class="n">starCountRef</span><span class="o">.</span><span class="na">onValue</span><span class="o">.</span><span class="na">listen</span><span class="p">((</span><span class="n">DatabaseEvent</span> <span class="n">event</span><span class="p">){</span>
    <span class="kd">final</span> <span class="n">data</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">snapshot</span><span class="o">.</span><span class="na">value</span><span class="p">;</span>
    <span class="n">updateStarCount</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="cm">/* 
        event.snapshot.exists =&gt; true or false
        event.snapshot =&gt; may be null
    */</span>

<span class="p">});</span>

<span class="cm">/* read once from remote / local */</span>
<span class="kd">final</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">();</span>
<span class="kd">final</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ref</span><span class="o">.</span><span class="na">child</span><span class="p">(</span><span class="s">'users/</span><span class="si">$userId</span><span class="s">'</span><span class="p">)</span><span class="o">.</span><span class="na">get</span><span class="p">();</span> <span class="c1">// get from remote, if not find local </span>
<span class="k">if</span><span class="p">(</span><span class="n">snapshot</span><span class="o">.</span><span class="na">exists</span><span class="p">){</span>
    <span class="n">print</span><span class="p">(</span><span class="n">snapshot</span><span class="o">.</span><span class="na">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span><span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"No data availbale"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// တကယ်ကို တစ်ခါတည်း ဖတ်မှာ၊ ပြီးတော့ local ကနေ ချက်ခြင်းလိုချင်တာမျိုး</span>
<span class="kd">final</span> <span class="n">event</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ref</span><span class="o">.</span><span class="na">once</span><span class="p">(</span><span class="n">DatabaseEventType</span><span class="o">.</span><span class="na">value</span><span class="p">);</span>
<span class="kd">final</span> <span class="n">username</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">snapshot</span><span class="o">.</span><span class="na">value</span><span class="o">?.</span><span class="na">username</span> <span class="o">??</span> <span class="s">"Anonymous"</span><span class="p">;</span>

<span class="c1">// insert and updating</span>
<span class="kt">void</span> <span class="nf">writeNewPost</span><span class="p">(</span><span class="kt">String</span> <span class="n">uid</span><span class="p">,</span> <span class="kt">String</span> <span class="n">username</span><span class="p">,</span> <span class="kt">String</span> <span class="n">picture</span><span class="p">,</span> <span class="kt">String</span> <span class="n">title</span><span class="p">,</span> <span class="kt">String</span> <span class="n">body</span><span class="p">){</span>
    <span class="kd">final</span> <span class="n">postData</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'author'</span> <span class="o">:</span> <span class="n">username</span><span class="p">,</span>
        <span class="s">'uid'</span> <span class="o">:</span> <span class="n">uid</span><span class="p">,</span>
        <span class="s">'body'</span> <span class="o">:</span> <span class="n">body</span><span class="p">,</span>
        <span class="s">'title'</span> <span class="o">:</span> <span class="n">title</span><span class="p">,</span>
        <span class="s">'starCount'</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">'authorPic'</span> <span class="o">:</span> <span class="n">picture</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// Get a key for a new post</span>
    <span class="c1">// .push() create new child</span>
    <span class="c1">// .key retrieve of newly created child</span>
    <span class="c1">// ဒီ key ကိုပဲ user-post မှာ ပြန်သုံးမယ်။</span>
    <span class="kd">final</span> <span class="n">newPostKey</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">()</span><span class="o">.</span><span class="na">child</span><span class="p">(</span><span class="s">'posts'</span><span class="p">)</span><span class="o">.</span><span class="na">push</span><span class="p">()</span><span class="o">.</span><span class="na">key</span><span class="p">;</span>
    <span class="c1">// update in two paths</span>
    <span class="kd">final</span> <span class="kt">Map</span><span class="p">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Map</span><span class="p">&gt;</span> <span class="n">updates</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="cm">/* u know, it's not linking, it's storing duplicate things */</span>
    <span class="n">updates</span><span class="p">[</span><span class="s">'/posts/</span><span class="si">$newPostKey</span><span class="s">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">postData</span><span class="p">;</span>
    <span class="n">updates</span><span class="p">[</span><span class="s">'/user-posts/</span><span class="si">$uid</span><span class="s">/</span><span class="si">$newsPostKey</span><span class="s">'</span><span class="p">]</span> <span class="o">=</span> <span class="n">postData</span><span class="p">;</span>
    <span class="c1">// ဒါက update အားလုံး failed ရင် failed ဒါမှမဟုတ် အကုန် success ပြမယ်။ actomicity ဆိုပါတော့ ။</span>
    <span class="k">return</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">()</span><span class="o">.</span><span class="na">update</span><span class="p">(</span><span class="n">updates</span><span class="p">);</span>

    <span class="cm">/* set / update callback functions */</span>
    <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span>
        <span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">'users/</span><span class="si">$userId</span><span class="s">/email'</span><span class="p">)</span>
        <span class="o">.</span><span class="na">set</span><span class="p">(</span><span class="n">updateEmailAddress</span><span class="p">)</span>
        <span class="o">.</span><span class="na">then</span><span class="p">((</span><span class="n">_</span><span class="p">){</span>
            <span class="c1">// data saved successfully</span>
        <span class="p">})</span>
        <span class="o">.</span><span class="na">catchError</span><span class="p">((</span><span class="n">error</span><span class="p">){</span>
            <span class="c1">// The write failed ...</span>
        <span class="p">})</span>
    <span class="p">);</span>

    <span class="c1">// ဖျတ်မယ်ဆိုရင် delete()</span>

    <span class="c1">// auto increment သုံးချင်ရင်</span>
    <span class="c1">// ServerValue.increment(1);</span>
    <span class="n">updates</span><span class="p">[</span><span class="s">"posts/</span><span class="si">$postId</span><span class="s">/startCount"</span><span class="p">]</span> <span class="o">=</span> <span class="n">ServerValue</span><span class="o">.</span><span class="na">increment</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>data စပြီး ဘယ်လို ဖတ်မလဲ?</p>

<p>လက်ရှိ record တစ်ခုတည်းကို ဖတ်ရုံပဲ။</p>

<p>name
first_digit
second_digit
final_digit</p>

<p>data structure ကို တက်နိုင်သမျှ nested မသုံးပဲ flat ဖြစ်နိုင်သမျှ ဖြစ်အောင်ထား။</p>

<p>read တွေ write တွေက auth user တွေကိုပဲ ပေးလုပ်တာ များတယ်။
ဒီတော့ firebase auth ပါ လိုလာမယ်။</p>

<p>String, boolean, int , double, Map, List သုံးလို့ရမယ်။</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">

</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>တက်နိုင်သမျှ key value တွေသာသုံး</p>

<h3 id="data-structure-for-mahar-by-ksmt">Data Structure for mahar-by-ksmt</h3>

<p>အကုန်လုံးက Json Object တစ်ခုတည်းမှာ ထည့်ထားမှာ ဆိုတော့ level one ရဲ့ key တွေက Table သဘောမျိုး ဖြစ်နေမယ်။
array မသုံးပဲ key-&gt;value pair တွေချည်းသုံးတာ ကောင်းမယ်။ undefined index မဖြစ်တော့ပဲ key မရှိတောင် null ဖြစ်နေတာမျိုး။</p>

<h3 id="er-diagram">ER Diagram</h3>

<p>အဓိက သုံးမယ့် Entity တွေက</p>

<ul>
  <li>User</li>
  <li>Intake</li>
</ul>

<p>လောလောဆယ်တော့ ဒီ (၂) ခုပဲ။</p>

<p>User ကလည်း လောလောဆယ် Firebase Auth မသုံးသေးတော့ အိုကေတယ်။</p>

<p>အိုကေ ဒီတော့ Intake ကိုပဲ စဉ်းစားကြတာပေါ့။</p>

<h3 id="intake">Intake</h3>

<ul>
  <li>_id</li>
  <li>date</li>
  <li>time</li>
  <li>digit</li>
  <li>name : Intake Name Object</li>
</ul>

<p>တစ်ခုရှိတာက name ကလည်း မျိုးစုံ ဖြစ်နိုင်တယ်။</p>

<h3 id="intakename">IntakeName</h3>
<ul>
  <li>_id</li>
  <li>name</li>
</ul>

<h3 id="user">User</h3>
<ul>
  <li>_id</li>
  <li>email</li>
  <li>name</li>
  <li>profile_pic_url</li>
</ul>

<h3 id="bet">Bet</h3>
<ul>
  <li>_id</li>
  <li>digit</li>
  <li>intake</li>
  <li>user</li>
</ul>

<p>ဒါကိုပဲ array တစ်ခုတည်းမှာ သိမ်းထားရင် ရပြီ။</p>

<h3 id="lucky">Lucky</h3>
<ul>
  <li>_id</li>
  <li>digit</li>
  <li>intake</li>
</ul>

<p>ဒါလည်း အိုကေပြီ ထင်တယ်။</p>

<p>Data တိုင်းကတော့ store လုပ်ပြီးသွားပြီ။</p>

<p>Report အပိုင်းနဲ့ အလျော်အစားပဲ ကျန်မယ်။</p>

<p>ပထမ Report အတွက်က Aggregrate Function နဲ့ Filter တွေ လိုမယ်။ နောက်ပြီး pagination ဘယ်လိုလုပ်လဲ ကြည့်ရမယ်။
data တွေကတော့ နေရာအစုံမှာ duplicate လုပ်မယ်ဆိုတာ သိထားပါ။</p>

<p>ဒါမှ မဟုတ် aggregrate မလုပ်ပဲ တိုက်ရိုက်တွက်ထားတာက ဒီဘက်မှာ ပိုအဆင်ပြေမလား?</p>

<p>ပထမဆုံး ကြည့်မှာက အခု intake မှာ ဘယ်ဂဏန်းတွေ ဘယ်လောက် ထိုးထားပြီးပြီလဲ?</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"bet_reports"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"_intakeId"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"0"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span><span class="w">
            </span><span class="nl">"1"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
            </span><span class="err">...</span><span class="w">
            </span><span class="nl">"99"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">150</span><span class="p">,</span><span class="w">
            </span><span class="nl">"sum"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">2000</span><span class="p">,</span><span class="w">
            </span><span class="nl">"lucky"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">55</span><span class="p">,</span><span class="w">
            </span><span class="nl">"win"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">1500</span><span class="p">,</span><span class="w">
            </span><span class="nl">"lose"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">500</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>path ကလည်း ဒါမျိုး ဖြစ်သွားမယ်။</p>

<p>bet_reports/_intakeId</p>

<p>realtime လည်း ဖြစ်မယ်။ နောက်ပြီး report လည်း ရေးထားပြီးသားဖြစ်မယ်။</p>

<p>ဒီအပေါ်က data ရရင် win / lose အခြေအနေကိုလည်း တိုက်ရိုက် ထုတ်ပြနိုင်နေမယ်။</p>

<p>Provider -&gt; Data Source တွေ ကြားထဲမှာပဲ stream သုံးပြီး Provider နဲ့ UI ကြားမှာတော့ NotifyListener အရင်အတိုင်း သွားကြတာပေါ့။</p>

<p>Provider &lt;-&gt; Repository ကြားမှာ က Clean Stream ဆိုလိုတာက Entity တွေပဲ သယ်ယူပို့ဆောင် လုပ်မယ်။
Repository &lt;-&gt; DataSource ကြားမှာလည်း အတူတူပဲ Clean Stream ကိုပဲ ဆက်သုံးမယ်။ ဒါပေမယ့် ဒီမှာ Failure ပြန်ကောင်း ပြန်လာမယ်။
DataSource &lt;-&gt; Firebase ကြားမှာတော့ Raw Stream ကို သုံးမယ်။ Raw Stream က ရလာတဲ့ Data ကို Clean လုပ်ပြီးမှ Repository အတွက် Clean Stream ကနေ Entity တွေ ပို့ပေးမယ်။ 
အဲ့မှာ Repository ကနေ Usecase က တဆင့် Data တွေကို Stream နဲ့ ထပ်ပို့ပေးမယ်။</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">MaharRepository</span><span class="p">{</span>
    <span class="cm">/* User Login အပိုင်းက UI တွေလည်း ပါတာဆိုတော့ ဘယ်လိုလုပ်ကြမလဲ? Provider နဲ့ UI အကြားမှာပဲ ထားမလား? */</span>
    <span class="n">Future</span><span class="p">&lt;</span><span class="n">Stream</span><span class="p">&lt;</span><span class="n">Intake</span><span class="p">&gt;,</span> <span class="n">Failure</span><span class="p">&gt;</span> <span class="n">getCurrentIntake</span><span class="p">({</span><span class="kd">required</span> <span class="kt">String</span> <span class="n">accessToken</span><span class="p">});</span>
    <span class="c1">// ဒါက admin အတွက်ပဲ။</span>
    <span class="n">Future</span><span class="p">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="n">Failure</span><span class="p">&gt;</span> <span class="n">setCurrentIntake</span><span class="p">({</span><span class="kd">required</span> <span class="kt">String</span> <span class="n">accessToken</span><span class="p">,</span> <span class="kd">required</span> <span class="n">Intake</span> <span class="n">intake</span><span class="p">});</span>

    <span class="n">Future</span><span class="p">&lt;</span><span class="kt">List</span><span class="p">&lt;</span><span class="n">Intake</span><span class="p">&gt;,</span> <span class="n">Failure</span><span class="p">&gt;</span> <span class="n">getIntakeListByDate</span><span class="p">({</span><span class="kd">required</span> <span class="kt">String</span> <span class="n">accessToken</span><span class="p">,</span> <span class="kd">required</span> <span class="n">Date</span> <span class="n">date</span><span class="p">});</span>
    <span class="n">Future</span><span class="p">&lt;</span><span class="kt">List</span><span class="p">&lt;</span><span class="n">Gift</span><span class="p">&gt;,</span> <span class="n">Failure</span><span class="p">&gt;</span> <span class="n">getGiftListByDate</span><span class="p">({</span><span class="kd">required</span> <span class="kt">String</span> <span class="n">accessToken</span><span class="p">,</span> <span class="kd">required</span> <span class="n">Date</span> <span class="n">date</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>
<p>အခု အခြေအနေအရတော့ Repository က အဓိက အကျဆုံးပဲ။</p>

<p>ပြီးမှ  Usecase ပေါ့ ။</p>

<p>Outline ရဖို့က Repository ရေးရင် ရပြီ။
အမှန်ကတော့ Use Case တွေ တန်းစီပြီး ချရေးရမှာ။</p>

<p>အိုကေ UseCase ဆိုပါတော့</p>

<p>ဆိုတော့ကာ လေလေ</p>

<h3 id="flatering-the-data-structure">Flatering the data structure</h3>

<p>တက်နိုင်သမျှ nest နေကြတာ ကျွန်တော်တို့အတွက် Google က အကြံပေးတဲ့  Flat Datastructure က အတော်လေး ထူးဆန်းတယ်။</p>

<h3 id="list-ထဲကို-data-append-လုပ်မယ်">List ထဲကို data append လုပ်မယ်</h3>
<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DatabaseReference</span> <span class="n">postListRef</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">"posts"</span><span class="p">);</span>
<span class="n">DatabaseReference</span> <span class="n">newPostRef</span> <span class="o">=</span> <span class="n">postListRef</span><span class="o">.</span><span class="na">push</span><span class="p">();</span>
<span class="n">newPostRef</span><span class="o">.</span><span class="na">set</span><span class="p">({</span>

<span class="p">});</span>
</code></pre></div></div>

<h3 id="children-တွေရဲ့-event-တွေကို-ဘယ်လို-listen-လုပ်ကြမလဲ">Children တွေရဲ့ Event တွေကို ဘယ်လို listen လုပ်ကြမလဲ</h3>

<p>collection တစ်ခုလုံးကို Listen လုပ်တာ မလုပ်ပဲ။ append လုပ်တာ။ update လုပ်တာ။ remove လုပ်တာလောက်ကိုပဲ တိတိကျကျ listen လုပ်ထားရင် ပိုပြီး effecient ဖြစ်တာပေါ့။</p>

<p>nested json တွေ အကုန်လုံးက path အနေနဲ့ သွားတာ။</p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">commentRef</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">"post-comments/</span><span class="si">$postId</span><span class="s">"</span><span class="p">);</span>
<span class="n">commentRef</span><span class="o">.</span><span class="na">onChildAdded</span><span class="o">.</span><span class="na">listen</span><span class="p">((</span><span class="n">event</span><span class="p">){</span>
    <span class="c1">// a new comment has been added</span>
<span class="p">});</span>
<span class="n">commentRef</span><span class="o">.</span><span class="na">onChildChanged</span><span class="o">.</span><span class="na">listen</span><span class="p">((</span><span class="n">event</span><span class="p">){</span>
    <span class="c1">// a comment has changed</span>
<span class="p">});</span>
<span class="n">commentRef</span><span class="o">.</span><span class="na">onChildRemoved</span><span class="o">.</span><span class="na">listen</span><span class="p">((</span><span class="n">event</span><span class="p">){</span>
    <span class="c1">// a comment has been removed</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="ဒါက-sorting-အပိုင်း">ဒါက sorting အပိုင်း</h3>
<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">myUserId</span> <span class="o">=</span> <span class="n">FirebaseAuth</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">currentUser</span><span class="o">?.</span><span class="na">uid</span><span class="p">;</span>
<span class="kd">final</span> <span class="n">topUserPostsRef</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">"user-posts/</span><span class="si">$myUserId</span><span class="s">"</span><span class="p">)</span><span class="o">.</span><span class="na">orderByChild</span><span class="p">(</span><span class="s">"starCount"</span><span class="p">);</span>
</code></pre></div></div>

<p>for nested json</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"posts"</span><span class="p">:{</span><span class="w">
        </span><span class="nl">"ts-functions"</span><span class="p">:{</span><span class="w">
            </span><span class="nl">"metrics"</span><span class="p">:{</span><span class="w">
                </span><span class="nl">"views"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w">
                </span><span class="nl">"likes"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">25000</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Why we should use TypeScript?"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"description"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"blah blah blah blah "</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="nl">"node-js"</span><span class="p">:{</span><span class="w">
            </span><span class="nl">"metrics"</span><span class="p">:{</span><span class="w">
                </span><span class="nl">"views"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">502</span><span class="p">,</span><span class="w">
                </span><span class="nl">"likes"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="mi">65203</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nl">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Node : The fall of JS"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"description"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"blah blah blah blah "</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="n">mostViewedPosts</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">"posts"</span><span class="p">)</span><span class="o">.</span><span class="na">orderByChild</span><span class="p">(</span><span class="s">"metrics/views"</span><span class="p">);</span>

<span class="c1">// orderByChild</span>
<span class="c1">// orderByKey</span>
<span class="c1">// orderByValue</span>

<span class="cm">/* We can use only one order by cretia */</span>
</code></pre></div></div>

<h3 id="filter-ဘယ်လိုလုပ်မလဲ">Filter ဘယ်လိုလုပ်မလဲ?</h3>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// limitToFirst</span>
<span class="c1">// limitToLast</span>
<span class="c1">// startAt</span>
<span class="c1">// startAfter</span>
<span class="c1">// endAt</span>
<span class="c1">// endBefore</span>
<span class="c1">// equalTo</span>

<span class="kd">final</span> <span class="n">recentPostsRef</span> <span class="o">=</span> <span class="n">FirebaseDatabase</span><span class="o">.</span><span class="na">instance</span><span class="o">.</span><span class="na">ref</span><span class="p">(</span><span class="s">'posts'</span><span class="p">)</span><span class="o">.</span><span class="na">limitToLast</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

</code></pre></div></div>

<p>** ရှာတာ ဖွေတာ မရဘူး ***
list နဲ့ ဆွဲထုတ်ရင်တော့ ရမယ်။</p>

<p>orderBy မှာ date ဘာညာသာရကာ သုံးလဲ sorting အတွက်ပဲ။
အိုကေ sorting အတွက် လုပ်တဲ့ နေရာမှာ where clause လို့ သဘောထားလို့တော့ ရမယ်။
မရဘူးပဲ။ where clause မှာက equal to ပါတယ်။ 
sorting / orderBy မှာက field name တစ်ခုပဲ ပါတာ။</p>

<p>filter မှာတော့ equalTo ဆိုတဲ့ emthod ပါတယ်။
ကိုယ်လိုချင်တဲ့ where clause သုံးလို့ရမလား ကြည့်ရအောင်။</p>

<p>ရပြီ</p>
<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dinosaursRef</span><span class="o">.</span><span class="na">orderByChild</span><span class="p">(</span><span class="s">"height"</span><span class="p">)</span><span class="o">.</span><span class="na">equalTo</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span> 
</code></pre></div></div>
<p>ဆိုတော့ကာ orderByChild နဲ့ equalTo ကို သုံးပြီး လိုချင်တဲ့ row အတိအကျကို filter လုပ်လို့ရမယ်။</p>

<p>pagination လိုချင်ရင် 
offset အနေနဲ့ .startAfter
limit အနေနဲ့ .limitToFirst</p>

<p>ဆိုပါတော့ ကိုယ်က</p>

<p>user ရဲ့ တစ်ရက်စာ bet list ကို ထုတ်ကြည့်ချင်တယ်။</p>

<p>သိမ်းထားတဲ့ ပုံစံက ဒါမျိုး ဖြစ်မယ်။</p>

<p>user-bets</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"user-bets"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"user_id"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"intake_id"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nl">"bet_id"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="err">//</span><span class="w"> </span><span class="err">bet</span><span class="w"> </span><span class="err">object</span><span class="w">
                </span><span class="p">},</span><span class="w">
                </span><span class="nl">"bet_id2"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                    </span><span class="err">//</span><span class="w"> </span><span class="err">bet</span><span class="w"> </span><span class="err">object</span><span class="w">
                </span><span class="p">}</span><span class="w">
            </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>@ input</p>
<ul>
  <li>userId</li>
  <li>date</li>
</ul>

<p>ပြန်လာရမှာက List<Intake></Intake></p>

<div class="language-dart highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>


  </div>

  <div class="date">
    Written on December 31, 2022
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          












        </footer>
      </div>
    </div>

    

    <script>
	window.fbAsyncInit = function() {
	  FB.init({
		appId      : '608464966533110',
		cookie     : true,
		xfbml      : true,
		version    : 'v9.0'
	  });
		
	  FB.AppEvents.logPageView();   
		
	};
  
	(function(d, s, id){
	   var js, fjs = d.getElementsByTagName(s)[0];
	   if (d.getElementById(id)) {return;}
	   js = d.createElement(s); js.id = id;
	   js.src = "https://connect.facebook.net/en_US/sdk.js";
	   fjs.parentNode.insertBefore(js, fjs);
	 }(document, 'script', 'facebook-jssdk'));

	 
FB.getLoginStatus(function(response) {
	console.log("getLoginStatus");
	console.log(response);
    statusChangeCallback(response);
});

function statusChangeCallback(response){
	console.log('response is');
	console.log(response);
	if(response.status == "connected"){
		console.log("user is logged in ");
	}
	else{
		console.log("user need to login");
		//FB.login();
	}
}
function checkLoginState() {
  FB.getLoginStatus(function(response) {
    statusChangeCallback(response);
  });
}

  </script>

  
<fb:login-button 
scope="public_profile,email"
onlogin="checkLoginState();">
</fb:login-button>
  </body>
</html>
