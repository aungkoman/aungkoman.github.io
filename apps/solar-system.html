<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Solar System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
        }
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            max-width: 280px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        #info-panel h1 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        button, input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #555;
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
            padding: 0;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #ddd;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #ddd;
            cursor: pointer;
            border-radius: 50%;
        }
        #speed-value {
            font-weight: bold;
        }
    </style>
</head>
<body>

    <!-- UI Panel -->
    <div id="info-panel">
        <h1>Controls</h1>
        <div class="control-group">
            <button id="play-pause-btn">Pause</button>
        </div>
        <div class="control-group">
            <label for="speed-slider">Time Speed: <span id="speed-value">1.0</span>x</label>
            <input type="range" id="speed-slider" min="0" max="10" step="0.1" value="1">
        </div>
        <div class="control-group">
            <button id="toggle-orbits-btn">Toggle Orbits</button>
        </div>
        <div class="control-group">
            <button id="toggle-scale-btn">Artistic Scale</button>
        </div>
    </div>

    <!-- Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <!-- Main application logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        let scene, camera, renderer, controls;
        let clock = new THREE.Clock();
        
        // --- STATE VARIABLES ---
        let isPaused = false;
        let timeSpeed = 1;
        let showOrbits = true;
        let scaleMode = 'artistic'; // 'artistic' or 'realistic'
        
        // To hold all celestial objects for easy access
        const celestialObjects = [];
        const orbitLines = [];

        // --- PLANET DATA ---
        // Artistic scale is for better viewing. Realistic scale is... vast and empty.
        const planetData = [
            { name: 'Mercury', color: 0x8c8c8c, radius: 0.38, distance: 5.8, orbitalSpeed: 4.7, rotationSpeed: 0.1 },
            { name: 'Venus', color: 0xffa500, radius: 0.95, distance: 10.8, orbitalSpeed: 3.5, rotationSpeed: -0.05 },
            { name: 'Earth', color: 0x0077ff, radius: 1, distance: 15, orbitalSpeed: 2.9, rotationSpeed: 1.0, moon: { radius: 0.27, distance: 1.5, orbitalSpeed: 5.1 } },
            { name: 'Mars', color: 0xff4500, radius: 0.53, distance: 22.8, orbitalSpeed: 2.4, rotationSpeed: 1.03 },
            { name: 'Jupiter', color: 0xd2b48c, radius: 4, distance: 40, orbitalSpeed: 1.3, rotationSpeed: 2.4 },
            { name: 'Saturn', color: 0xf0e68c, radius: 3.5, distance: 60, orbitalSpeed: 0.9, rotationSpeed: 2.3, ring: { innerRadius: 4.5, outerRadius: 7 } },
            { name: 'Uranus', color: 0xadd8e6, radius: 2, distance: 80, orbitalSpeed: 0.6, rotationSpeed: -1.4 },
            { name: 'Neptune', color: 0x4169e1, radius: 1.9, distance: 100, orbitalSpeed: 0.5, rotationSpeed: 1.5 },
        ];


        function init() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 70);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            // --- LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 2, 300);
            scene.add(pointLight);

            // --- OBJECT CREATION ---
            // Sun
            const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, map: createSunTexture() });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.add(pointLight);
            scene.add(sun);
            celestialObjects.push({ mesh: sun, data: { rotationSpeed: 0.05 } });

            // Planets, Moons, Rings, Orbits
            planetData.forEach(data => {
                // Pivot for orbital rotation
                const pivot = new THREE.Object3D();
                scene.add(pivot);

                // Planet mesh
                const planetGeometry = new THREE.SphereGeometry(data.radius, 32, 32);
                const planetMaterial = new THREE.MeshStandardMaterial({ map: createPlanetTexture(data.color) });
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.x = data.distance;
                pivot.add(planet);

                const celestial = { mesh: planet, pivot: pivot, data: data };
                celestialObjects.push(celestial);

                // Moon
                if (data.moon) {
                    const moonPivot = new THREE.Object3D();
                    planet.add(moonPivot);
                    
                    const moonGeometry = new THREE.SphereGeometry(data.moon.radius, 16, 16);
                    const moonMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    moon.position.x = data.moon.distance;
                    moonPivot.add(moon);
                    celestialObjects.push({ mesh: moon, pivot: moonPivot, data: data.moon, isMoon: true });
                }

                // Ring
                if (data.ring) {
                    const ringGeometry = new THREE.RingGeometry(data.ring.innerRadius, data.ring.outerRadius, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        map: createRingTexture(data.color), 
                        side: THREE.DoubleSide, 
                        transparent: true,
                        opacity: 0.8
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = -Math.PI * 0.5;
                    planet.add(ring);
                }
                
                // Orbit Line
                const orbitGeometry = new THREE.RingGeometry(data.distance, data.distance, 128);
                const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
                const orbit = new THREE.LineLoop(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI * 0.5;
                scene.add(orbit);
                orbitLines.push(orbit);
            });

            // UI Event Listeners
            setupUI();

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        // --- TEXTURE GENERATION ---
        function createPlanetTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Base color
            context.fillStyle = new THREE.Color(color).getStyle();
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Add some noise and patterns
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 1.5;
                const lightness = Math.random() * 0.4 + 0.8; // 80% to 120% of base color
                const noisyColor = new THREE.Color(color).multiplyScalar(lightness);
                context.fillStyle = `rgba(${noisyColor.r * 255}, ${noisyColor.g * 255}, ${noisyColor.b * 255}, ${Math.random() * 0.5})`;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        function createSunTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');

            context.fillStyle = '#FFFF00';
            context.fillRect(0, 0, 128, 128);
            
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 128;
                const y = Math.random() * 128;
                const radius = Math.random() * 1.2;
                context.fillStyle = `rgba(255, ${Math.floor(Math.random() * 100 + 155)}, 0, ${Math.random() * 0.8})`;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createRingTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 2;
            const context = canvas.getContext('2d');

            for (let i = 0; i < canvas.width; i++) {
                const lightness = Math.random() * 0.3 + 0.7; // 70% to 100%
                const ringColor = new THREE.Color(color).multiplyScalar(lightness);
                context.fillStyle = `rgba(${ringColor.r * 255}, ${ringColor.g * 255}, ${ringColor.b * 255}, ${Math.random() * 0.5 + 0.5})`;
                context.fillRect(i, 0, 1, 2);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            return texture;
        }

        // --- UI LOGIC ---
        function setupUI() {
            document.getElementById('play-pause-btn').addEventListener('click', () => {
                isPaused = !isPaused;
                document.getElementById('play-pause-btn').textContent = isPaused ? 'Play' : 'Pause';
            });
            
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                timeSpeed = parseFloat(e.target.value);
                document.getElementById('speed-value').textContent = timeSpeed.toFixed(1);
            });
            
            document.getElementById('toggle-orbits-btn').addEventListener('click', () => {
                showOrbits = !showOrbits;
                orbitLines.forEach(line => line.visible = showOrbits);
            });

            document.getElementById('toggle-scale-btn').addEventListener('click', () => {
                scaleMode = scaleMode === 'artistic' ? 'realistic' : 'artistic';
                document.getElementById('toggle-scale-btn').textContent = scaleMode === 'artistic' ? 'Artistic Scale' : 'Realistic Scale';
                updateScales();
            });
        }
        
        function updateScales() {
            // NOTE: True realistic scale is impossible to view. These are just illustrative.
            const planetScale = (scaleMode === 'realistic') ? 0.05 : 1;
            const distanceScale = (scaleMode === 'realistic') ? 2 : 1;
            
            celestialObjects.forEach(obj => {
                if (obj.data.radius) { // If it has a radius (i.e., not the sun)
                    obj.mesh.scale.set(planetScale, planetScale, planetScale);
                }
                if (obj.pivot && obj.data.distance) {
                    if (obj.isMoon) {
                        obj.mesh.position.x = obj.data.distance * planetScale * 5; // Scale moon distance too
                    } else {
                        obj.mesh.position.x = obj.data.distance * distanceScale;
                    }
                }
            });

            orbitLines.forEach((line, index) => {
                const distance = planetData[index].distance * distanceScale;
                // Recreating geometry is heavy, scaling the object is easier
                line.scale.set(distance, distance, distance);
            });
            // Normalize orbit lines since we are scaling them
            if (scaleMode === 'realistic') {
                 orbitLines.forEach(line => line.scale.set(line.scale.x / line.geometry.parameters.radius, line.scale.y / line.geometry.parameters.radius, 1));
            } else {
                 orbitLines.forEach(line => line.scale.set(1,1,1));
            }


        }


        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            controls.update();
            
            if (!isPaused) {
                celestialObjects.forEach(obj => {
                    // Axial rotation
                    if (obj.data.rotationSpeed) {
                        obj.mesh.rotation.y += obj.data.rotationSpeed * timeSpeed * delta;
                    }

                    // Orbital rotation
                    if (obj.pivot && obj.data.orbitalSpeed) {
                        obj.pivot.rotation.y += (obj.data.orbitalSpeed / 100) * timeSpeed * delta;
                    }
                });
            }

            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- START ---
        init();
    </script>
</body>
</html>
